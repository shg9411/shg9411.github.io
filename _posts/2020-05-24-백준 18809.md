[BOJ - Gaaaaaaaaaarden(18809)](https://www.acmicpc.net/problem/18809)
===

BFS, DFS, python
---

* [문제 링크](https://www.acmicpc.net/problem/18809)   

* 풀이 방법  
  - 배양액을 뿌릴 수 있는 좌표들을 리스트에 담아놓은 후, 모든 조합을 구해서 배양액을 퍼뜨리면 되는 문제였습니다.  
  조합은 DFS ,python의 itertools.permutaion 또는 c++의 next_permutaion 등을 사용해서 쉽게 구할 수 있고  
  각 조합들을 queue를 사용하여 BFS하면 되는 문제입니다.  
  
  
## 내 코드  

```python
from itertools import combinations
from collections import deque


def bfs(gq, rq):
    tmpGarden = [garden[i][:] for i in range(N)]
    cnt = 0
    for i, j in gq:
        tmpGarden[i][j] = 0
    for i, j in rq:
        tmpGarden[i][j] = 0
    #같은 시간에 도착함을 알기 위해 val값 선언
    val = 2
    while gq and rq:
        #초록 배양액을 뿌린 곳은 val값으로 변경
        for _ in range(len(gq)):
            x, y = gq.popleft()
            if tmpGarden[x][y] < 0:
                continue
            if x > 0 and tmpGarden[x-1][y] == 1:
                tmpGarden[x-1][y] = val
                gq.append([x-1, y])
            if y > 0 and tmpGarden[x][y-1] == 1:
                tmpGarden[x][y-1] = val
                gq.append([x, y-1])
            if x < N-1 and tmpGarden[x+1][y] == 1:
                tmpGarden[x+1][y] = val
                gq.append([x+1, y])
            if y < M-1 and tmpGarden[x][y+1] == 1:
                tmpGarden[x][y+1] = val
                gq.append([x, y+1])
        #빨간 배양액이 퍼질 위치가 val값이면 꽃이 핌
        #꽃이 핀 위치에서는 배양액이 더 이상 퍼지지 않기에 음수로 
        for _ in range(len(rq)):
            x, y = rq.popleft()
            if x > 0:
                if tmpGarden[x-1][y] == 1:
                    tmpGarden[x-1][y] = -val
                    rq.append([x-1, y])
                elif tmpGarden[x-1][y] == val:
                    tmpGarden[x-1][y] = -val
                    cnt += 1
            if y > 0:
                if tmpGarden[x][y-1] == 1:
                    tmpGarden[x][y-1] = -1
                    rq.append([x, y-1])
                elif tmpGarden[x][y-1] == val:
                    tmpGarden[x][y-1] = -val
                    cnt += 1
            if x < N-1:
                if tmpGarden[x+1][y] == 1:
                    tmpGarden[x+1][y] = -val
                    rq.append([x+1, y])
                elif tmpGarden[x+1][y] == val:
                    tmpGarden[x+1][y] = -val
                    cnt += 1
            if y < M-1:
                if tmpGarden[x][y+1] == 1:
                    tmpGarden[x][y+1] = -val
                    rq.append([x, y+1])
                elif tmpGarden[x][y+1] == val:
                    tmpGarden[x][y+1] = -val
                    cnt += 1
        val += 1
    return cnt


if __name__ == '__main__':
    N, M, G, R = map(int, input().split())
    #정원
    garden = [] 
     #뿌릴 수 있는 곳
    spoil = []
    for i in range(N):
        garden.append(list(map(int, input().split())))
        for j in range(M):
            #뿌릴 수 있는 곳 저장
            if garden[i][j] == 2:
                spoil.append((i, j))
                garden[i][j] = 1
    res = 0
    #뿌릴 수 있는 곳 구하기
    for comb in combinations(range(len(spoil)), G+R):
        comb = set(comb)
        #초록 배양액을 뿌릴 수 있는 조합을 구하고 나머지를 빨간 배양액을 뿌림
        for g in combinations(comb, G):
            g = set(g)
            green = deque(spoil[i] for i in g)
            red = deque(spoil[i] for i in comb-g)
            res = max(res, bfs(green, red))
    print(res)

```
  
  
  
파이썬으로 통과한 첫 타자임을 자랑스럽게 생각합니다.  
  
![](https://user-images.githubusercontent.com/34259849/82738796-6c2f6000-9d75-11ea-8f34-3c96684ba8c5.PNG)

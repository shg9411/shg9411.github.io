[BOJ - 가장 긴 증가하는 부분 수열2(12015)](https://www.acmicpc.net/problem/12015)
===

이분 탐색, LIS, 동적 계획법, python
---

* 문제 설명
  - 수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.  
  예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우,  
  가장 긴 증가하는 부분 수열은 A = {**10**, **20**, 10, **30**, 20, **50**} 이고, 길이는 4이다.
  
   

* 입력  
  - 첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다.  
  둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000,000)

  
* 비슷한 문제
  - [가장 긴 증가하는 부분 수열(11055)](https://www.acmicpc.net/problem/11055)
  - [가장 긴 증가하는 부분 수열3(12738)](https://www.acmicpc.net/problem/12738)
  
## 내 코드  
#DP(O(N^2))  
```python
a = int(input())
arr = list(map(int, input().split()))
dp = [0] * a
for i in range(a):
    for j in range(i):
        if arr[i] > arr[j] and dp[i] < dp[j]:
            dp[i] = dp[j]
    dp[i] += 1
print(max(dp))


```  
  
#이분탐색(O(NlogN))
```python
import bisect


def lis(arr):
    lis_arr = [0]

    for n in arr:
        if lis_arr[-1] < n:
            lis_arr.append(n)
        else:
            where = bisect.bisect_left(lis_arr, n)
            lis_arr[where] = n
    return len(lis_arr)-1


input()
print(lis(list(map(int, input().split()))))

 ```  

 
## 문제풀이  
 
**LIS(Longest Increasing Subsequence)**  
LIS란 최장 증가 부분 수열이란 뜻이다.  
이 수열의 길이를 구하는 것은 동적 계획법(DP)과 이분탐색의 방법으로 각각 구할 수 있다.
DP를 사용할 경우 시간복잡도는 **O(N^2)** 이다.
외부 for문의 숫자가 내부 for문의 숫자보다 큰 경우 dp배열의 값을 가져와서 1증가시켜주는 방식이다.  
[나무위키](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4#toc)에 자세하게 설명되어있으며, O(n^2)의 시간복잡도를 가지기에 [가장 긴 증가하는 부분 수열(11055)](https://www.acmicpc.net/problem/11055) 와 같이 1,000까지의 범위를 가진 문제를 풀 수는 있지만  
이 문제와 같이 1,000,000의 범위를 가진 문제를 풀기에는 적합하지 않은 알고리즘이다.  
  
  
이 문제의 경우 bisect를 사용하여 이분탐색을 활용하는데  
맨 앞부터 숫자를 검사하여 결과 배열의 마지막 값보다 큰 경우에는 결과 배열의 마지막에 붙여주고,  
그렇지 않은 경우 결과 배열에서 그 값이 들어갈 위치를 이분탐색하여 그 인덱스의 값을 대치시켜준다.  
  
  [1, 4, 5, 2, 3, 6]의 경우를 예로 들자면  
  초기 결과배열 res = [0] (입력값이 1 ~ 10^6이기에 맨 앞에 0을 미리 넣어두었다.)
  **1의 경우** - res = [0, 1] (1이 0보다 크기에 뒤에 삽입)  
  **4의 경우** - res = [0, 1, 4] (4가 1보다 크기에 뒤에 삽입)  
  **5의 경우** - res = [0, 1, 4, 5] (5이 4보다 크기에 뒤에 삽입)  
  **2의 경우** - res = [0, 1, 2, 5]  
  2는 5보다 작기에 이분탐색으로 결과 배열 중 들어갈 수 있는 가장 마지막 자리의 값을 대치시켜줍니다.  
  (1보다 크고 5보다 작은 4의 자리에 들어갈 수 있음)  
  **3의 경우** - res = [0, 1, 2, 3]  (동일합니다.)  
  **6의 경우** - res = [0, 1, 2, 3, 6]  
  위와 같이 res의 길이는 처음 넣어준 0을 제외하고 4라는 값이 반환됩니다.  
    
  저는 [1, 4, 5, 2]와 같은 경우가 반례가 될 것이라고 생각했지만,  
  위의 예에서 2까지만 진행되었을 경우를 보자면 LIS의 길이는 0을 제외하고 3이 됩니다. ( [1, 4, 5]의 경우)  
  
  가장 긴 증가하는 부분 수열, 2, 3 문제는 이분 탐색을 이용하고 위의 소스 코드를 조금만 수정하면 (입력값의 범위가 다르기 때문)  **'맞았습니다!!'** 를 받을 수 있습니다.  
  하지만 이 알고리즘의 경우 정확한 부분 수열의 값을 가지는 것이 아니고, 부분 수열의 길이를 출력하는 데에만 사용할 수 있습니다.  
  수열의 내용을 구하는 방법은 다음에 게시하도록 하겠습니다.  
  

